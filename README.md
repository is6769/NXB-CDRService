# Сервис CDR

## Описание

Сервис CDR (Call Data Record) — это компонент телекоммуникационной системы, отвечающий за генерацию, хранение и передачу данных о телефонных вызовах.

## Назначение

Сервис CDR выполняет следующие функции:
- Генерация исторических данных о звонках за последний год
- Непрерывная генерация новых записей о звонках
- Сохранение CDR-записей в базе данных
- Передача CDR в систему биллинга через RabbitMQ

## Процесс генерации CDR

### Начальная генерация данных

При запуске сервиса происходит многопоточная генерация исторических данных о звонках за последний год:

1. В методе `runInitialGeneration()` создаётся несколько потоков (количество задаётся параметром `const.numberOfGenerationThreads`)
2. Каждый поток выполняет метод `generateCdrForOneYear()`, создавая от 1000 до 2000 записей о звонках
3. Сгенерированные записи проверяются на пересечения (один абонент не может участвовать в двух звонках одновременно)
4. Валидные записи добавляются в очередь `PriorityBlockingQueue` с сортировкой по времени окончания звонка
5. Для каждого звонка создаётся зеркальная запись для второго участника разговора

### Алгоритм генерации записей

Для каждой записи CDR:

1. Из базы данных выбираются случайные абоненты (обслуживаемый и другой)
2. Определяется тип вызова (01 - исходящий, 02 - входящий)
3. Генерируются случайные время начала и длительность звонка в пределах последнего года
4. Создаётся объект CDR с собранными данными
5. Проверяется, не участвует ли любой из абонентов в другом звонке в это время
6. Проверяется, не пересекает ли звонок полночь (если пересекает, разбивается на несколько записей)
7. Для каждой записи создаётся зеркальная запись для другого участника разговора
8. Если все проверки пройдены, записи добавляются в очередь CDR

### Зеркальные записи

Метод `makeMirrorCdrs()` создаёт зеркальные записи для каждого звонка:

1. Для каждой созданной записи создаётся зеркальная запись
2. В зеркальной записи меняются местами номера абонентов (servicedMsisdn и otherMsisdn)
3. Тип звонка меняется на противоположный (01 → 02, 02 → 01)
4. Временные параметры сохраняются
5. Обе записи добавляются в очередь для сохранения в БД

### Защита от пересечений звонков

Метод `isCallAllowed()` гарантирует, что один абонент не может участвовать в нескольких звонках одновременно:

1. Для проверяемого номера и временного интервала просматриваются существующие записи
2. Если обнаружена запись, где номер уже участвует в звонке и временные интервалы пересекаются, метод возвращает `false`
3. Метод возвращает `true` только если звонок не пересекается с существующими

### Разделение записей CDR на границе дней

Метод `splitIfCrossesMidnight()` разделяет звонки, пересекающие полночь, на отдельные записи для каждого дня:

1. Проверяется, пересекает ли текущий звонок полночь
2. Если пересекает, создаются отдельные записи: одна до 23:59:59 и другая начиная с 00:00:00
3. Процесс повторяется, если звонок пересекает несколько полночей

## Процесс сохранения и передачи CDR

### Периодическое сохранение в БД

1. Метод `persistQueuedData()` запускается по расписанию (периодичность задаётся в конфигурации)
2. Извлекает случайное количество (до 5) CDR из очереди
3. Пакетно сохраняет извлеченные записи в базу данных

### Отправка в RabbitMQ

Метод `consumeDataFromDB()` в `CdrConsumerService` выполняет:

1. Проверку наличия непереданных записей в БД (минимум `const.numberOfRecordsInCDR` со статусом NEW)
2. Извлечение заданного количества непереданных записей из БД
3. Преобразование записей в DTO-объекты
4. Отправку пакета данных в очередь RabbitMQ с ключом маршрутизации, указанным в конфигурации
5. Обновление статуса отправленных записей на CONSUMED в БД

## Структура данных CDR

Каждая запись содержит:

- Идентификатор записи (автоинкремент)
- Тип вызова (01 - исходящий, 02 - входящий)
- Номер обслуживаемого абонента (servicedMsisdn)
- Номер другого абонента (otherMsisdn)
- Дата и время начала вызова
- Дата и время окончания вызова
- Статус обработки (NEW/CONSUMED)

## Технические детали

### Конфигурационные параметры

- `const.numberOfGenerationThreads`: количество потоков для генерации данных
- `const.numberOfRecordsInCDR`: количество записей, отправляемых за одну пачку
- `const.scheduled.consume-cdr-rate`: периодичность запуска обработки CDR
- `const.scheduled.produce-cdr-rate`: периодичность сохранения CDR в БД
- `const.rabbitmq.cdr.CDR_EXCHANGE_NAME`: имя обменника RabbitMQ для CDR
- `const.rabbitmq.cdr.CDR_QUEUE_NAME`: имя очереди RabbitMQ для CDR
- `const.rabbitmq.cdr.CDR_ROUTING_KEY`: ключ маршрутизации для сообщений CDR
- `const.rabbitmq.dead-letter.*`: настройки для очереди "мертвых писем"

### База данных

**H2 Database**
- JDBC URL: `jdbc:h2:mem:cdr-db`
- Пользователь: `sa`
- Пароль: `password`
- Веб-консоль: http://localhost:8082/h2-console

### Структура базы данных

База данных содержит следующие таблицы:
- `subscribers`: информация об абонентах (id, msisdn)
- `cdrs`: записи о звонках с полями, соответствующими структуре данных CDR

### Используемые технологии

- Java 17
- Spring Boot 3.4.4
- Spring Cloud 2024.0.1
- Spring Data JPA
- Spring AMQP (RabbitMQ)
- H2 Database
- Liquibase для миграций БД
- Lombok для уменьшения шаблонного кода
- JUnit 5 и Mockito для тестирования
